{"ast":null,"code":"import produce from 'immer';\nexport const preset1 = setGrid => {\n  clearGrid(setGrid);\n  setGrid(grid => {\n    return produce(grid, gridCopy => {\n      gridCopy[3][5]['alive'] = true;\n      gridCopy[3][6]['alive'] = true;\n      gridCopy[3][7]['alive'] = true;\n    });\n  });\n};\nexport const preset2 = setGrid => {\n  clearGrid(setGrid);\n  setGrid(grid => {\n    return produce(grid, gridCopy => {\n      gridCopy[3][5]['alive'] = true;\n      gridCopy[3][6]['alive'] = true;\n      gridCopy[4][6]['alive'] = true;\n      gridCopy[4][5]['alive'] = true;\n      gridCopy[2][7]['alive'] = true;\n      gridCopy[3][8]['alive'] = true;\n      gridCopy[3][9]['alive'] = true;\n      gridCopy[4][8]['alive'] = true;\n      gridCopy[4][9]['alive'] = true;\n      gridCopy[5][8]['alive'] = true;\n      gridCopy[5][9]['alive'] = true;\n      gridCopy[5][6]['alive'] = true;\n      gridCopy[6][5]['alive'] = true;\n      gridCopy[6][6]['alive'] = true;\n      gridCopy[7][5]['alive'] = true;\n      gridCopy[7][6]['alive'] = true;\n      gridCopy[7][4]['alive'] = true;\n      gridCopy[8][6]['alive'] = true;\n      gridCopy[9][6]['alive'] = true;\n      gridCopy[9][7]['alive'] = true;\n      gridCopy[10][7]['alive'] = true;\n      gridCopy[10][8]['alive'] = true;\n      gridCopy[10][9]['alive'] = true;\n      gridCopy[9][9]['alive'] = true;\n      gridCopy[9][10]['alive'] = true;\n      gridCopy[8][8]['alive'] = true;\n    });\n  });\n};\nexport const preset3 = setGrid => {};\nexport const randomPreset = setGrid => {\n  setGrid(grid => {\n    return produce(grid, gridCopy => {\n      for (let i = 0; i < gridCopy.length; i++) {\n        let i = Math.floor(Math.random() * gridCopy.length - 1 + 0);\n        let j = Math.floor(Math.random() * gridCopy.length - 1 + 0);\n        gridCopy[i][j].alive = true;\n      }\n    });\n  });\n};\n\nconst clearGrid = setGrid => {\n  let arr = new Array(25);\n\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = new Array(25);\n  }\n\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      arr[i][j] = {\n        alive: false,\n        coor: [i, j]\n      };\n    }\n  }\n\n  setGrid(arr);\n};\n\nexport const countNeighbors = (grid, buffer, coordinates, i, j, state) => {\n  let count_neighbors = 0; // check the top cell\n\n  if (coordinates.hasOwnProperty(`${i - 1},${j}`)) {\n    if (coordinates[`${i - 1},${j}`].alive === true) {\n      count_neighbors++;\n    }\n  } else {\n    if (grid[i - 1][j].alive === true) {\n      count_neighbors++;\n    }\n  } // check top right corner cell\n\n\n  if (coordinates.hasOwnProperty(`${i - 1},${j + 1}`)) {\n    if (coordinates[`${i - 1},${j + 1}`].alive === true) {\n      count_neighbors++;\n    }\n  } else {\n    if (grid[i - 1][j + 1].alive === true) {\n      count_neighbors++;\n    }\n  } //check cell to the right\n\n\n  if (coordinates.hasOwnProperty(`${i},${j + 1}`)) {\n    if (coordinates[`${i},${j + 1}`].alive === true) {\n      count_neighbors++;\n    }\n  } else {\n    if (grid[i][j + 1].alive === true) {\n      count_neighbors++;\n    }\n  } //check bottom right corner cell\n\n\n  if (coordinates.hasOwnProperty(`${i + 1},${j + 1}`)) {\n    if (coordinates[`${i + 1},${j + 1}`].alive === true) {\n      count_neighbors++;\n    }\n  } else {\n    if (grid[i + 1][j + 1].alive === true) {\n      count_neighbors++;\n    }\n  } //check bottom cell\n\n\n  if (coordinates.hasOwnProperty(`${i + 1},${j}`)) {\n    if (coordinates[`${i + 1},${j}`].alive === true) {\n      count_neighbors++;\n    }\n  } else {\n    if (grid[i + 1][j].alive === true) {\n      count_neighbors++;\n    }\n  } // check bottom left corner cell\n\n\n  if (coordinates.hasOwnProperty(`${i + 1},${j - 1}`)) {\n    if (coordinates[`${i + 1},${j - 1}`].alive === true) {\n      count_neighbors++;\n    }\n  } else {\n    if (grid[i + 1][j - 1].alive === true) {\n      count_neighbors++;\n    }\n  } // check cell to the left\n\n\n  if (coordinates.hasOwnProperty(`${i},${j - 1}`)) {\n    if (coordinates[`${i},${j - 1}`].alive === true) {\n      count_neighbors++;\n    }\n  } else {\n    if (grid[i][j - 1].alive === true) {\n      count_neighbors++;\n    }\n  } //check top left corner\n\n\n  if (coordinates.hasOwnProperty(`${i - 1},${j - 1}`)) {\n    if (coordinates[`${i - 1},${j - 1}`].alive === true) {\n      count_neighbors++;\n    }\n  } else {\n    if (grid[i - 1][j - 1].alive === true) {\n      count_neighbors++;\n    }\n  } // should it stay alive or not\n\n\n  if (state === true) {\n    if (count_neighbors < 2 || count_neighbors > 3) {\n      buffer[i][j].alive = false;\n    }\n  } else if (state === false) {\n    if (count_neighbors === 3) {\n      buffer[i][j].alive = true;\n    }\n  }\n};\nexport const wrapCellsAround = (grid, coordinates) => {\n  const build_top_row = () => {\n    let index = 0; //add corner cells\n\n    coordinates['-1,-1'] = grid[grid.length - 1][grid.length - 1];\n    coordinates[`-1,${grid.length}`] = grid[grid.length - 1][0];\n\n    while (index < grid.length) {\n      coordinates[`-1,${index}`] = grid[grid.length - 1][index];\n      index++;\n    }\n  };\n\n  const build_bottom_row = () => {\n    let index = 0; //add corner cells\n\n    coordinates[`${grid.length},-1`] = grid[0][grid.length - 1];\n    coordinates[`${grid.length},${grid.length}`] = grid[0][0];\n\n    while (index < grid.length) {\n      coordinates[`${grid.length},${index}`] = grid[0][index];\n      index++;\n    }\n  };\n\n  const build_left_col = () => {\n    let index = 0;\n\n    while (index < grid.length) {\n      coordinates[`${index},-1`] = grid[index][grid.length - 1];\n      index++;\n    }\n  };\n\n  const build_right_col = () => {\n    let index = 0;\n\n    while (index < grid.length) {\n      coordinates[`${index},${grid.length}`] = grid[index][0];\n      index++;\n    }\n  };\n\n  build_top_row();\n  build_bottom_row();\n  build_left_col();\n  build_right_col();\n};","map":{"version":3,"sources":["/Users/leanan/Desktop/coding/game-of-life/client/src/utils/helper.js"],"names":["produce","preset1","setGrid","clearGrid","grid","gridCopy","preset2","preset3","randomPreset","i","length","Math","floor","random","j","alive","arr","Array","coor","countNeighbors","buffer","coordinates","state","count_neighbors","hasOwnProperty","wrapCellsAround","build_top_row","index","build_bottom_row","build_left_col","build_right_col"],"mappings":"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","sourcesContent":["import produce from 'immer';\n\nexport const preset1 = (setGrid) => {\n\n    clearGrid(setGrid);\n\n    setGrid(grid => {\n\n      return produce(grid, gridCopy => {\n\n        gridCopy[3][5]['alive'] = true\n        gridCopy[3][6]['alive'] = true\n        gridCopy[3][7]['alive'] = true\n      })\n    })\n\n}\n\nexport const preset2 = (setGrid) => {\n\n  clearGrid(setGrid);\n\n  setGrid(grid => {\n\n    return produce(grid, gridCopy => {\n\n      gridCopy[3][5]['alive'] = true\n      gridCopy[3][6]['alive'] = true\n      gridCopy[4][6]['alive'] = true\n      gridCopy[4][5]['alive'] = true\n    \n      gridCopy[2][7]['alive'] = true\n      gridCopy[3][8]['alive'] = true\n      gridCopy[3][9]['alive'] = true\n    \n      gridCopy[4][8]['alive'] = true\n      gridCopy[4][9]['alive'] = true\n      gridCopy[5][8]['alive'] = true\n      gridCopy[5][9]['alive'] = true\n    \n      gridCopy[5][6]['alive'] = true\n      gridCopy[6][5]['alive'] = true\n      gridCopy[6][6]['alive'] = true\n    \n      gridCopy[7][5]['alive'] = true\n      gridCopy[7][6]['alive'] = true\n      gridCopy[7][4]['alive'] = true\n    \n      gridCopy[8][6]['alive'] = true\n      gridCopy[9][6]['alive'] = true\n      gridCopy[9][7]['alive'] = true\n      gridCopy[10][7]['alive'] = true\n      gridCopy[10][8]['alive'] = true\n      gridCopy[10][9]['alive'] = true\n      gridCopy[9][9]['alive'] = true\n    \n      gridCopy[9][10]['alive'] = true\n      gridCopy[8][8]['alive'] = true\n\n    })\n  })\n\n}\n\nexport const preset3 = (setGrid) => {\n\n}\n\nexport const randomPreset = (setGrid) => {\n\n    setGrid(grid => {\n\n      return produce(grid, gridCopy => {\n\n        for (let i = 0; i < gridCopy.length; i++) {\n          let i = Math.floor((Math.random() * gridCopy.length - 1) + 0);\n          let j = Math.floor((Math.random() * gridCopy.length - 1) + 0);\n          gridCopy[i][j].alive = true;\n        }\n\n      })\n    })\n}\n\n\nconst clearGrid = (setGrid) => {\n\n  let arr = new Array(25);\n      \n  for(let i = 0; i < arr.length; i++) {\n    arr[i] = new Array(25)\n  }\n\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      arr[i][j] = {alive: false, coor: [i,j]}\n    }\n  }\n  setGrid(arr)\n\n}\n\nexport const countNeighbors = (grid, buffer, coordinates, i, j, state) => {\n\n    let count_neighbors = 0;\n\n    // check the top cell\n    if (coordinates.hasOwnProperty(`${i-1},${j}`)) {\n      if (coordinates[`${i-1},${j}`].alive === true) {\n        count_neighbors ++;\n      }\n    } else {\n      if (grid[i-1][j].alive === true) {\n        count_neighbors ++;\n      }\n    }\n\n    // check top right corner cell\n    if (coordinates.hasOwnProperty(`${i-1},${j+1}`)) {\n      if (coordinates[`${i-1},${j+1}`].alive === true) {\n        count_neighbors ++;\n      }\n    } else {\n      if (grid[i-1][j+1].alive === true) {\n        count_neighbors ++;\n      }\n    }\n\n    //check cell to the right\n    if (coordinates.hasOwnProperty(`${i},${j+1}`)) {\n      if (coordinates[`${i},${j+1}`].alive === true) {\n        count_neighbors ++;\n      }\n    } else {\n      if (grid[i][j+1].alive === true) {\n        count_neighbors ++;\n      }\n    }\n\n    //check bottom right corner cell\n    if (coordinates.hasOwnProperty(`${i+1},${j+1}`)) {\n      if (coordinates[`${i+1},${j+1}`].alive === true) {\n        count_neighbors ++;\n      } \n    } else {\n      if (grid[i+1][j+1].alive === true) {\n        count_neighbors ++;\n      }\n    }\n\n    //check bottom cell\n    if (coordinates.hasOwnProperty(`${i+1},${j}`)) {\n      if (coordinates[`${i+1},${j}`].alive === true) {\n        count_neighbors ++;\n      }\n    } else {\n      if (grid[i+1][j].alive === true) {\n        count_neighbors ++;\n      }\n    }\n\n    // check bottom left corner cell\n    if (coordinates.hasOwnProperty(`${i+1},${j-1}`)) {\n      if (coordinates[`${i+1},${j-1}`].alive === true) {\n        count_neighbors ++;\n      }\n    } else {\n      if (grid[i+1][j-1].alive === true) {\n        count_neighbors ++;\n      }\n    }\n\n    // check cell to the left\n    if (coordinates.hasOwnProperty(`${i},${j-1}`)) {\n      if (coordinates[`${i},${j-1}`].alive === true) {\n        count_neighbors ++;\n      }\n    } else {\n      if (grid[i][j-1].alive === true) {\n        count_neighbors ++;\n      }\n    }\n\n    //check top left corner\n    if (coordinates.hasOwnProperty(`${i-1},${j-1}`)) {\n      if (coordinates[`${i-1},${j-1}`].alive === true) {\n        count_neighbors ++;\n      }\n    } else {\n      if (grid[i-1][j-1].alive === true) {\n        count_neighbors ++;\n      }\n    }\n\n    // should it stay alive or not\n    if (state === true) {\n      if (count_neighbors < 2 || count_neighbors > 3) {\n        buffer[i][j].alive = false;\n      } \n    } else if (state === false) {\n      if (count_neighbors === 3) {\n        buffer[i][j].alive = true;\n      } \n    }\n  }\n\n\nexport const wrapCellsAround = (grid, coordinates) => {\n\n  const build_top_row = () => {\n    let index = 0;\n\n    //add corner cells\n    coordinates['-1,-1'] = grid[grid.length - 1][grid.length - 1];\n    coordinates[`-1,${grid.length}`] = grid[grid.length - 1][0];\n\n    while(index < grid.length) {\n      coordinates[`-1,${index}`] = grid[grid.length - 1][index];\n      index ++;\n    }\n  }\n\n  const build_bottom_row = () => {\n    let index = 0;\n\n    //add corner cells\n    coordinates[`${grid.length},-1`] = grid[0][grid.length-1];\n    coordinates[`${grid.length},${grid.length}`] = grid[0][0];\n\n    while(index < grid.length) {\n      coordinates[`${grid.length},${index}`] = grid[0][index];\n      index ++;\n    }\n\n  }\n\n  const build_left_col = () => {\n    let index = 0;\n\n    while(index < grid.length) {\n      coordinates[`${index},-1`] = grid[index][grid.length - 1];\n      index ++;\n    }\n\n  }\n\n  const build_right_col = () => {\n    let index = 0;\n\n    while(index < grid.length) {\n      coordinates[`${index},${grid.length}`] = grid[index][0];\n      index ++;\n    }\n  }\n  build_top_row();\n  build_bottom_row();\n  build_left_col();\n  build_right_col();\n\n}"]},"metadata":{},"sourceType":"module"}